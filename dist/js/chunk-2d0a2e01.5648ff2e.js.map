{"version":3,"sources":["webpack:///./node_modules/@ionic/core/dist/esm/legacy/input-shims-09d70723.js"],"names":["__webpack_require__","r","__webpack_exports__","d","startInputShims","_chunk_c90aaa66_js__WEBPACK_IMPORTED_MODULE_0__","cloneMap","WeakMap","relocateInput","componentEl","inputEl","shouldRelocate","inputRelativeY","has","addClone","removeClone","isFocused","input","getRootNode","activeElement","parentEl","parentNode","clonedEl","cloneNode","classList","add","tabIndex","appendChild","set","doc","ownerDocument","tx","dir","style","pointerEvents","transform","clone","get","delete","remove","enableHideCaretOnScroll","scrollEl","scrollHideCaret","shouldHideCaret","onBlur","hideCaret","showCaret","addEventListener","removeEventListener","SKIP_SELECTOR","enableInputBlurring","focused","didScroll","document","onScroll","onFocusin","onTouchend","ev","active","matches","tapped","target","closest","setTimeout","blur","SCROLL_ASSIST_SPEED","getScrollData","contentEl","keyboardHeight","itemEl","calcScrollData","getBoundingClientRect","defaultView","innerHeight","inputRect","contentRect","platformHeight","inputTop","top","inputBottom","bottom","visibleAreaTop","visibleAreaBottom","Math","min","safeAreaTop","safeAreaBottom","distanceToBottom","distanceToTop","desiredScrollAmount","round","scrollAmount","distance","abs","duration","scrollDuration","max","scrollPadding","inputSafeY","enableScrollAssist","coord","touchStart","Object","touchEnd","endCoord","hasPointerMoved","preventDefault","stopPropagation","jsSetFocus","scrollData","focus","scrollByPoint","then","threshold","startCoord","deltaX","x","deltaY","y","PADDING_TIMER_KEY","enableScrollPadding","setScrollPadding","onFocusout","tagName","parentElement","el","timer","clearTimeout","setProperty","INPUT_BLURRING","SCROLL_PADDING","config","getNumber","scrollAssist","getBoolean","inputBlurring","inputs","Array","from","querySelectorAll","hideCaretMap","scrollAssistMap","registerInput","shadowRoot","querySelector","rmFn","unregisterInput","fn","_i","inputs_1","length","body","event"],"mappings":"kHAAAA,EAAAC,EAAAC,GAAAF,EAAAG,EAAAD,EAAA,oCAAAE,IAAA,IAAAC,EAAAL,EAAA,QACAM,EAAA,IAAAC,QACAC,EAAA,SAAAC,EAAAC,EAAAC,EAAAC,QACA,IAAAA,IAAoCA,EAAA,GACpCN,EAAAO,IAAAJ,KAAAE,IAGAA,EACAG,EAAAL,EAAAC,EAAAE,GAGAG,EAAAN,EAAAC,KAGAM,EAAA,SAAAC,GACA,OAAAA,MAAAC,cAAAC,eAEAL,EAAA,SAAAL,EAAAC,EAAAE,GAUA,IAAAQ,EAAAV,EAAAW,WAEAC,EAAAZ,EAAAa,WAAA,GACAD,EAAAE,UAAAC,IAAA,gBACAH,EAAAI,UAAA,EACAN,EAAAO,YAAAL,GACAhB,EAAAsB,IAAAnB,EAAAa,GACA,IAAAO,EAAApB,EAAAqB,cACAC,EAAA,QAAAF,EAAAG,IAAA,WACAvB,EAAAwB,MAAAC,cAAA,OACAxB,EAAAuB,MAAAE,UAAA,eAAAJ,EAAA,MAAAnB,EAAA,kBAEAG,EAAA,SAAAN,EAAAC,GACA,IAAA0B,EAAA9B,EAAA+B,IAAA5B,GACA2B,IACA9B,EAAAgC,OAAA7B,GACA2B,EAAAG,UAEA9B,EAAAwB,MAAAC,cAAA,GACAxB,EAAAuB,MAAAE,UAAA,IAEAK,EAAA,SAAA/B,EAAAC,EAAA+B,GACA,IAAAA,IAAA/B,EACA,oBAEA,IAAAgC,EAAA,SAAAC,GACA3B,EAAAN,IACAF,EAAAC,EAAAC,EAAAiC,IAGAC,EAAA,WAA8B,OAAApC,EAAAC,EAAAC,GAAA,IAC9BmC,EAAA,WAAiC,OAAAH,GAAA,IACjCI,EAAA,WAAiC,OAAAJ,GAAA,IAIjC,OAHAD,EAAAM,iBAAA,iBAAAF,GACAJ,EAAAM,iBAAA,eAAAD,GACApC,EAAAqC,iBAAA,OAAAH,GACA,WACAH,EAAAO,oBAAA,iBAAAH,GACAJ,EAAAO,oBAAA,eAAAF,GACApC,EAAAqC,iBAAA,UAAAH,KAGAK,EAAA,6BACAC,EAAA,WACA,IAAAC,GAAA,EACAC,GAAA,EACAvB,EAAAwB,SACAC,EAAA,WACAF,GAAA,GAEAG,EAAA,WACAJ,GAAA,GAEAK,EAAA,SAAAC,GAEA,GAAAL,EACAA,GAAA,MADA,CAIA,IAAAM,EAAA7B,EAAAV,cACA,GAAAuC,IAIAA,EAAAC,QAAAV,GAAA,CAIA,IAAAW,EAAAH,EAAAI,OACAD,IAAAF,IAGAE,EAAAD,QAAAV,IAAAW,EAAAE,QAAAb,KAGAE,GAAA,EAEAY,WAAA,WACAZ,GACAO,EAAAM,QAES,SAKT,OAHAnC,EAAAkB,iBAAA,iBAAAO,GACAzB,EAAAkB,iBAAA,UAAAQ,GAAA,GACA1B,EAAAkB,iBAAA,WAAAS,GAAA,GACA,WACA3B,EAAAmB,oBAAA,iBAAAM,GAAA,GACAzB,EAAAmB,oBAAA,UAAAO,GAAA,GACA1B,EAAAmB,oBAAA,WAAAQ,GAAA,KAGAS,EAAA,GACAC,EAAA,SAAAzD,EAAA0D,EAAAC,GACA,IAAAC,EAAA5D,EAAAqD,QAAA,wBAAArD,EACA,OAAA6D,EAAAD,EAAAE,wBAAAJ,EAAAI,wBAAAH,EAAA3D,EAAAqB,cAAA0C,YAAAC,cAEAH,EAAA,SAAAI,EAAAC,EAAAP,EAAAQ,GAEA,IAAAC,EAAAH,EAAAI,IACAC,EAAAL,EAAAM,OAEAC,EAAAN,EAAAG,IACAI,EAAAC,KAAAC,IAAAT,EAAAK,OAAAJ,EAAAR,GAEAiB,EAAAJ,EAAA,GACAK,EAAA,GAAAJ,EAEAK,EAAAD,EAAAP,EACAS,EAAAH,EAAAR,EAEAY,EAAAN,KAAAO,MAAAH,EAAA,GACAA,EACAC,EAAA,GACAA,EACA,GAGAG,EAAAR,KAAAC,IAAAK,EAAAZ,EAAAI,GACAW,EAAAT,KAAAU,IAAAF,GACAG,EAAAF,EAAA3B,EACA8B,EAAAZ,KAAAC,IAAA,IAAAD,KAAAa,IAAA,IAAAF,IACA,OACAH,eACAI,iBACAE,cAAA7B,EACA8B,WAAA,GAAArB,EAAAQ,KAGAc,EAAA,SAAA1F,EAAAC,EAAAyD,EAAAC,GACA,IAAAgC,EACAC,EAAA,SAAA5C,GACA2C,EAAgBE,OAAAjG,EAAA,KAAAiG,CAAY7C,IAE5B8C,EAAA,SAAA9C,GAEA,GAAA2C,EAAA,CAIA,IAAAI,EAAuBF,OAAAjG,EAAA,KAAAiG,CAAY7C,GAGnCgD,EAAA,EAAAL,EAAAI,IAAAxF,EAAAN,KACA+C,EAAAiD,iBACAjD,EAAAkD,kBAEAC,EAAAnG,EAAAC,EAAAyD,EAAAC,MAKA,OAFA3D,EAAAsC,iBAAA,aAAAsD,GAAA,GACA5F,EAAAsC,iBAAA,WAAAwD,GAAA,GACA,WACA9F,EAAAuC,oBAAA,aAAAqD,GAAA,GACA5F,EAAAuC,oBAAA,WAAAuD,GAAA,KAGAK,EAAA,SAAAnG,EAAAC,EAAAyD,EAAAC,GACA,IAAAyC,EAAA3C,EAAAzD,EAAA0D,EAAAC,GACAe,KAAAU,IAAAgB,EAAAlB,cAAA,EAGAjF,EAAAoG,SAMAtG,EAAAC,EAAAC,GAAA,EAAAmG,EAAAX,YACAxF,EAAAoG,QAEA3C,EAAA4C,cAAA,EAAAF,EAAAlB,aAAAkB,EAAAd,gBAAAiB,KAAA,WAGAxG,EAAAC,EAAAC,GAAA,EAAAmG,EAAAX,YAEAxF,EAAAoG,YAGAL,EAAA,SAAAQ,EAAAC,EAAAV,GACA,GAAAU,GAAAV,EAAA,CACA,IAAAW,EAAAD,EAAAE,EAAAZ,EAAAY,EACAC,EAAAH,EAAAI,EAAAd,EAAAc,EACA1B,EAAAuB,IAAAE,IACA,OAAAzB,EAAAqB,IAEA,UAEAM,EAAA,mBACAC,EAAA,SAAApD,GACA,IAAAvC,EAAAwB,SACAE,EAAA,SAAAE,GACAgE,EAAAhE,EAAAI,OAAAO,IAEAsD,EAAA,SAAAjE,GACAgE,EAAAhE,EAAAI,OAAA,IAIA,OAFAhC,EAAAkB,iBAAA,UAAAQ,GACA1B,EAAAkB,iBAAA,WAAA2E,GACA,WACA7F,EAAAmB,oBAAA,UAAAO,GACA1B,EAAAmB,oBAAA,WAAA0E,KAGAD,EAAA,SAAAxG,EAAAmD,GACA,aAAAnD,EAAA0G,WAGA1G,EAAA2G,eAAA,cAAA3G,EAAA2G,cAAAD,YAGA1G,EAAA2G,gBACA3G,EAAA2G,6BACA,kBAAA3G,EAAA2G,4BAAAD,SAFA,CAKA,IAAAE,EAAA5G,EAAA6C,QAAA,eACA,UAAA+D,EAAA,CAGA,IAAAC,EAAAD,EAAAN,GACAO,GACAC,aAAAD,GAEA1D,EAAA,EACAyD,EAAA5F,MAAA+F,YAAA,oBAAA5D,EAAA,MAGAyD,EAAAN,GAAAxD,WAAA,WACA8D,EAAA5F,MAAA+F,YAAA,4BACS,QAGTC,GAAA,EACAC,GAAA,EACA9H,EAAA,SAAA+H,GACA,IAAAtG,EAAAwB,SACAe,EAAA+D,EAAAC,UAAA,sBACAC,EAAAF,EAAAG,WAAA,mBACAzF,EAAAsF,EAAAG,WAAA,wBACAC,EAAAJ,EAAAG,WAAA,oBACArC,EAAAkC,EAAAG,WAAA,oBACAE,EAAAC,MAAAC,KAAA7G,EAAA8G,iBAAA,4BACAC,EAAA,IAAArI,QACAsI,EAAA,IAAAtI,QACAuI,EAAA,SAAArI,GACA,IAAAC,GAAAD,EAAAsI,YAAAtI,GAAAuI,cAAA,WAAAvI,EAAAsI,YAAAtI,GAAAuI,cAAA,YACAvG,EAAAhC,EAAAqD,QAAA,eACA,GAAApD,EAAA,CAGA,GAAA+B,GAAAI,IAAA+F,EAAA/H,IAAAJ,GAAA,CACA,IAAAwI,EAAAzG,EAAA/B,EAAAC,EAAA+B,GACAmG,EAAAhH,IAAAnB,EAAAwI,GAEA,GAAAxG,GAAA4F,IAAAQ,EAAAhI,IAAAJ,GAAA,CACAwI,EAAA9C,EAAA1F,EAAAC,EAAA+B,EAAA2B,GACAyE,EAAAjH,IAAAnB,EAAAwI,MAGAC,EAAA,SAAAzI,GACA,GAAAoC,EAAA,CACA,IAAAsG,EAAAP,EAAAvG,IAAA5B,GACA0I,GACAA,IAEAP,EAAAtG,OAAA7B,GAEA,GAAA4H,EAAA,CACAc,EAAAN,EAAAxG,IAAA5B,GACA0I,GACAA,IAEAN,EAAAvG,OAAA7B,KAGA8H,GAAAN,GACA/E,IAEA+C,GAAAiC,GACAV,EAAApD,GAKA,QAAAgF,EAAA,EAAAC,EAAAb,EAAuCY,EAAAC,EAAAC,OAAsBF,IAAA,CAC7D,IAAAnI,EAAAoI,EAAAD,GACAN,EAAA7H,GAEAY,EAAA0H,KAAAxG,iBAAA,2BAAAyG,GACAV,EAAAU,EAAA3F,UAEAhC,EAAA0H,KAAAxG,iBAAA,6BAAAyG,GACAN,EAAAM,EAAA3F","file":"js/chunk-2d0a2e01.5648ff2e.js","sourcesContent":["import { p as pointerCoord } from './chunk-c90aaa66.js';\nvar cloneMap = new WeakMap();\nvar relocateInput = function (componentEl, inputEl, shouldRelocate, inputRelativeY) {\n    if (inputRelativeY === void 0) { inputRelativeY = 0; }\n    if (cloneMap.has(componentEl) === shouldRelocate) {\n        return;\n    }\n    if (shouldRelocate) {\n        addClone(componentEl, inputEl, inputRelativeY);\n    }\n    else {\n        removeClone(componentEl, inputEl);\n    }\n};\nvar isFocused = function (input) {\n    return input === input.getRootNode().activeElement;\n};\nvar addClone = function (componentEl, inputEl, inputRelativeY) {\n    // this allows for the actual input to receive the focus from\n    // the user's touch event, but before it receives focus, it\n    // moves the actual input to a location that will not screw\n    // up the app's layout, and does not allow the native browser\n    // to attempt to scroll the input into place (messing up headers/footers)\n    // the cloned input fills the area of where native input should be\n    // while the native input fakes out the browser by relocating itself\n    // before it receives the actual focus event\n    // We hide the focused input (with the visible caret) invisible by making it scale(0),\n    var parentEl = inputEl.parentNode;\n    // DOM WRITES\n    var clonedEl = inputEl.cloneNode(false);\n    clonedEl.classList.add('cloned-input');\n    clonedEl.tabIndex = -1;\n    parentEl.appendChild(clonedEl);\n    cloneMap.set(componentEl, clonedEl);\n    var doc = componentEl.ownerDocument;\n    var tx = doc.dir === 'rtl' ? 9999 : -9999;\n    componentEl.style.pointerEvents = 'none';\n    inputEl.style.transform = \"translate3d(\" + tx + \"px,\" + inputRelativeY + \"px,0) scale(0)\";\n};\nvar removeClone = function (componentEl, inputEl) {\n    var clone = cloneMap.get(componentEl);\n    if (clone) {\n        cloneMap.delete(componentEl);\n        clone.remove();\n    }\n    componentEl.style.pointerEvents = '';\n    inputEl.style.transform = '';\n};\nvar enableHideCaretOnScroll = function (componentEl, inputEl, scrollEl) {\n    if (!scrollEl || !inputEl) {\n        return function () { return; };\n    }\n    var scrollHideCaret = function (shouldHideCaret) {\n        if (isFocused(inputEl)) {\n            relocateInput(componentEl, inputEl, shouldHideCaret);\n        }\n    };\n    var onBlur = function () { return relocateInput(componentEl, inputEl, false); };\n    var hideCaret = function () { return scrollHideCaret(true); };\n    var showCaret = function () { return scrollHideCaret(false); };\n    scrollEl.addEventListener('ionScrollStart', hideCaret);\n    scrollEl.addEventListener('ionScrollEnd', showCaret);\n    inputEl.addEventListener('blur', onBlur);\n    return function () {\n        scrollEl.removeEventListener('ionScrollStart', hideCaret);\n        scrollEl.removeEventListener('ionScrollEnd', showCaret);\n        inputEl.addEventListener('ionBlur', onBlur);\n    };\n};\nvar SKIP_SELECTOR = 'input, textarea, [no-blur]';\nvar enableInputBlurring = function () {\n    var focused = true;\n    var didScroll = false;\n    var doc = document;\n    var onScroll = function () {\n        didScroll = true;\n    };\n    var onFocusin = function () {\n        focused = true;\n    };\n    var onTouchend = function (ev) {\n        // if app did scroll return early\n        if (didScroll) {\n            didScroll = false;\n            return;\n        }\n        var active = doc.activeElement;\n        if (!active) {\n            return;\n        }\n        // only blur if the active element is a text-input or a textarea\n        if (active.matches(SKIP_SELECTOR)) {\n            return;\n        }\n        // if the selected target is the active element, do not blur\n        var tapped = ev.target;\n        if (tapped === active) {\n            return;\n        }\n        if (tapped.matches(SKIP_SELECTOR) || tapped.closest(SKIP_SELECTOR)) {\n            return;\n        }\n        focused = false;\n        // TODO: find a better way, why 50ms?\n        setTimeout(function () {\n            if (!focused) {\n                active.blur();\n            }\n        }, 50);\n    };\n    doc.addEventListener('ionScrollStart', onScroll);\n    doc.addEventListener('focusin', onFocusin, true);\n    doc.addEventListener('touchend', onTouchend, false);\n    return function () {\n        doc.removeEventListener('ionScrollStart', onScroll, true);\n        doc.removeEventListener('focusin', onFocusin, true);\n        doc.removeEventListener('touchend', onTouchend, false);\n    };\n};\nvar SCROLL_ASSIST_SPEED = 0.3;\nvar getScrollData = function (componentEl, contentEl, keyboardHeight) {\n    var itemEl = componentEl.closest('ion-item,[ion-item]') || componentEl;\n    return calcScrollData(itemEl.getBoundingClientRect(), contentEl.getBoundingClientRect(), keyboardHeight, componentEl.ownerDocument.defaultView.innerHeight);\n};\nvar calcScrollData = function (inputRect, contentRect, keyboardHeight, platformHeight) {\n    // compute input's Y values relative to the body\n    var inputTop = inputRect.top;\n    var inputBottom = inputRect.bottom;\n    // compute visible area\n    var visibleAreaTop = contentRect.top;\n    var visibleAreaBottom = Math.min(contentRect.bottom, platformHeight - keyboardHeight);\n    // compute safe area\n    var safeAreaTop = visibleAreaTop + 15;\n    var safeAreaBottom = visibleAreaBottom * 0.5;\n    // figure out if each edge of the input is within the safe area\n    var distanceToBottom = safeAreaBottom - inputBottom;\n    var distanceToTop = safeAreaTop - inputTop;\n    // desiredScrollAmount is the negated distance to the safe area according to our calculations.\n    var desiredScrollAmount = Math.round((distanceToBottom < 0)\n        ? -distanceToBottom\n        : (distanceToTop > 0)\n            ? -distanceToTop\n            : 0);\n    // our calculations make some assumptions that aren't always true, like the keyboard being closed when an input\n    // gets focus, so make sure we don't scroll the input above the visible area\n    var scrollAmount = Math.min(desiredScrollAmount, inputTop - visibleAreaTop);\n    var distance = Math.abs(scrollAmount);\n    var duration = distance / SCROLL_ASSIST_SPEED;\n    var scrollDuration = Math.min(400, Math.max(150, duration));\n    return {\n        scrollAmount: scrollAmount,\n        scrollDuration: scrollDuration,\n        scrollPadding: keyboardHeight,\n        inputSafeY: -(inputTop - safeAreaTop) + 4\n    };\n};\nvar enableScrollAssist = function (componentEl, inputEl, contentEl, keyboardHeight) {\n    var coord;\n    var touchStart = function (ev) {\n        coord = pointerCoord(ev);\n    };\n    var touchEnd = function (ev) {\n        // input cover touchend/mouseup\n        if (!coord) {\n            return;\n        }\n        // get where the touchend/mouseup ended\n        var endCoord = pointerCoord(ev);\n        // focus this input if the pointer hasn't moved XX pixels\n        // and the input doesn't already have focus\n        if (!hasPointerMoved(6, coord, endCoord) && !isFocused(inputEl)) {\n            ev.preventDefault();\n            ev.stopPropagation();\n            // begin the input focus process\n            jsSetFocus(componentEl, inputEl, contentEl, keyboardHeight);\n        }\n    };\n    componentEl.addEventListener('touchstart', touchStart, true);\n    componentEl.addEventListener('touchend', touchEnd, true);\n    return function () {\n        componentEl.removeEventListener('touchstart', touchStart, true);\n        componentEl.removeEventListener('touchend', touchEnd, true);\n    };\n};\nvar jsSetFocus = function (componentEl, inputEl, contentEl, keyboardHeight) {\n    var scrollData = getScrollData(componentEl, contentEl, keyboardHeight);\n    if (Math.abs(scrollData.scrollAmount) < 4) {\n        // the text input is in a safe position that doesn't\n        // require it to be scrolled into view, just set focus now\n        inputEl.focus();\n        return;\n    }\n    // temporarily move the focus to the focus holder so the browser\n    // doesn't freak out while it's trying to get the input in place\n    // at this point the native text input still does not have focus\n    relocateInput(componentEl, inputEl, true, scrollData.inputSafeY);\n    inputEl.focus();\n    // scroll the input into place\n    contentEl.scrollByPoint(0, scrollData.scrollAmount, scrollData.scrollDuration).then(function () {\n        // the scroll view is in the correct position now\n        // give the native text input focus\n        relocateInput(componentEl, inputEl, false, scrollData.inputSafeY);\n        // ensure this is the focused input\n        inputEl.focus();\n    });\n};\nvar hasPointerMoved = function (threshold, startCoord, endCoord) {\n    if (startCoord && endCoord) {\n        var deltaX = (startCoord.x - endCoord.x);\n        var deltaY = (startCoord.y - endCoord.y);\n        var distance = deltaX * deltaX + deltaY * deltaY;\n        return distance > (threshold * threshold);\n    }\n    return false;\n};\nvar PADDING_TIMER_KEY = '$ionPaddingTimer';\nvar enableScrollPadding = function (keyboardHeight) {\n    var doc = document;\n    var onFocusin = function (ev) {\n        setScrollPadding(ev.target, keyboardHeight);\n    };\n    var onFocusout = function (ev) {\n        setScrollPadding(ev.target, 0);\n    };\n    doc.addEventListener('focusin', onFocusin);\n    doc.addEventListener('focusout', onFocusout);\n    return function () {\n        doc.removeEventListener('focusin', onFocusin);\n        doc.removeEventListener('focusout', onFocusout);\n    };\n};\nvar setScrollPadding = function (input, keyboardHeight) {\n    if (input.tagName !== 'INPUT') {\n        return;\n    }\n    if (input.parentElement && input.parentElement.tagName === 'ION-INPUT') {\n        return;\n    }\n    if (input.parentElement &&\n        input.parentElement.parentElement &&\n        input.parentElement.parentElement.tagName === 'ION-SEARCHBAR') {\n        return;\n    }\n    var el = input.closest('ion-content');\n    if (el === null) {\n        return;\n    }\n    var timer = el[PADDING_TIMER_KEY];\n    if (timer) {\n        clearTimeout(timer);\n    }\n    if (keyboardHeight > 0) {\n        el.style.setProperty('--keyboard-offset', keyboardHeight + \"px\");\n    }\n    else {\n        el[PADDING_TIMER_KEY] = setTimeout(function () {\n            el.style.setProperty('--keyboard-offset', '0px');\n        }, 120);\n    }\n};\nvar INPUT_BLURRING = true;\nvar SCROLL_PADDING = true;\nvar startInputShims = function (config) {\n    var doc = document;\n    var keyboardHeight = config.getNumber('keyboardHeight', 290);\n    var scrollAssist = config.getBoolean('scrollAssist', true);\n    var hideCaret = config.getBoolean('hideCaretOnScroll', true);\n    var inputBlurring = config.getBoolean('inputBlurring', true);\n    var scrollPadding = config.getBoolean('scrollPadding', true);\n    var inputs = Array.from(doc.querySelectorAll('ion-input, ion-textarea'));\n    var hideCaretMap = new WeakMap();\n    var scrollAssistMap = new WeakMap();\n    var registerInput = function (componentEl) {\n        var inputEl = (componentEl.shadowRoot || componentEl).querySelector('input') || (componentEl.shadowRoot || componentEl).querySelector('textarea');\n        var scrollEl = componentEl.closest('ion-content');\n        if (!inputEl) {\n            return;\n        }\n        if (!!scrollEl && hideCaret && !hideCaretMap.has(componentEl)) {\n            var rmFn = enableHideCaretOnScroll(componentEl, inputEl, scrollEl);\n            hideCaretMap.set(componentEl, rmFn);\n        }\n        if (!!scrollEl && scrollAssist && !scrollAssistMap.has(componentEl)) {\n            var rmFn = enableScrollAssist(componentEl, inputEl, scrollEl, keyboardHeight);\n            scrollAssistMap.set(componentEl, rmFn);\n        }\n    };\n    var unregisterInput = function (componentEl) {\n        if (hideCaret) {\n            var fn = hideCaretMap.get(componentEl);\n            if (fn) {\n                fn();\n            }\n            hideCaretMap.delete(componentEl);\n        }\n        if (scrollAssist) {\n            var fn = scrollAssistMap.get(componentEl);\n            if (fn) {\n                fn();\n            }\n            scrollAssistMap.delete(componentEl);\n        }\n    };\n    if (inputBlurring && INPUT_BLURRING) {\n        enableInputBlurring();\n    }\n    if (scrollPadding && SCROLL_PADDING) {\n        enableScrollPadding(keyboardHeight);\n    }\n    // Input might be already loaded in the DOM before ion-device-hacks did.\n    // At this point we need to look for all of the inputs not registered yet\n    // and register them.\n    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n        var input = inputs_1[_i];\n        registerInput(input);\n    }\n    doc.body.addEventListener('ionInputDidLoad', function (event) {\n        registerInput(event.target);\n    });\n    doc.body.addEventListener('ionInputDidUnload', function (event) {\n        unregisterInput(event.target);\n    });\n};\nexport { startInputShims };\n"],"sourceRoot":""}